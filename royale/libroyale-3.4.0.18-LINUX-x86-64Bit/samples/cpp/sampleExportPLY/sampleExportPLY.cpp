#include <iostream>
#include <thread>
#include <chrono>
#include <mutex>
#include <fstream>
#include <sstream>
#include <string>

#include <royale.hpp>
#include <royale/IPlaybackStopListener.hpp>
#include <royale/IReplay.hpp>

using namespace royale;
using namespace std;

namespace
{
    class MyListener : public IDepthDataListener
    {
    public:
        MyListener()
        {
            // reset the current frame number
            m_frameNumber = 0;
        }

        void writePLY (const string &filename, const royale::DepthData *data)
        {
            // For an explanation of the PLY file format please have a look at
            // https://en.wikipedia.org/wiki/PLY_(file_format)

            ofstream outputFile;
            stringstream stringStream;

            outputFile.open (filename, ofstream::out);

            if (outputFile.fail())
            {
                cerr << "Outputfile " << filename << " could not be opened!" << endl;
                return;
            }
            else
            {
                // if the file was opened successfully write the PLY header
                stringStream << "ply" << endl;
                stringStream << "format ascii 1.0" << endl;
                stringStream << "comment Generated by sampleExport" << endl;
                stringStream << "element vertex " << data->points.size() << endl;
                stringStream << "property float x" << endl;
                stringStream << "property float y" << endl;
                stringStream << "property float z" << endl;
                stringStream << "element face 0" << endl;
                stringStream << "property list uchar int vertex_index" << endl;
                stringStream << "end_header" << endl;

                // output XYZ coordinates into one line
                for (size_t i = 0; i < data->points.size(); ++i)
                {
                    stringStream << data->points.at (i).x << " " << data->points.at (i).y << " " << data->points.at (i).z << endl;
                }

                // output stringstream to file and close it
                outputFile << stringStream.str();
                outputFile.close();
            }
        }

        void onNewData (const DepthData *data)
        {
            stringstream filename;

            m_frameNumber++;

            cout << "Exporting frame " << m_frameNumber << " of " << numFrames << endl;

            filename << m_frameNumber << ".ply";
            writePLY (filename.str(), data);
        }

        uint32_t numFrames;     // Total number of frames in the recording
        string rrfFile;         // Recording file that was opened

    private:
        uint32_t m_frameNumber; // the current frame number
    };

    class MyPlaybackStopListener : public IPlaybackStopListener
    {
    public:
        MyPlaybackStopListener()
        {
            playbackRunning = true;
        }

        void onPlaybackStopped()
        {
            lock_guard<mutex> lock (m_stopMutex);
            playbackRunning = false;
        }

        void waitForStop()
        {
            bool running = true;
            do
            {
                {
                    lock_guard<mutex> lock (m_stopMutex);
                    running = playbackRunning;
                }

                this_thread::sleep_for (chrono::milliseconds (50));
            }
            while (running);
        }

    private:
        mutex m_stopMutex;      // Mutex to synchronize the access to playbackRunning
        bool playbackRunning;   // Shows if the playback is still running
    };

}

int main (int argc, char *argv[])
{
    // This is the data listener which will receive callbacks.  It's declared
    // before the cameraDevice so that, if this function exits with a 'return'
    // statement while the camera is still capturing, it will still be in scope
    // until the cameraDevice's destructor implicitly deregisters the listener.
    MyListener listener;

    // PlaybackStopListener which will be called as soon as the playback stops.
    MyPlaybackStopListener stopListener;

    // this represents the main camera device object
    unique_ptr<ICameraDevice> cameraDevice;

    // check the command line for a given file
    if (argc < 2)
    {
        cout << "Usage sampleExport rrfFileToExport" << endl;
        return 1;
    }
    else
    {
        // the camera manager can also be used to open recorded files
        CameraManager manager;

        // create a device from the file
        cameraDevice = manager.createCamera (argv[1]);
    }

    // if the file was loaded correctly the cameraDevice is now available
    if (cameraDevice == nullptr)
    {
        cerr << "Cannot load the file " << argv[1] << endl;
        return 1;
    }

    listener.rrfFile = argv[1];

    // cast the cameraDevice to IReplay which offers more options for playing
    // back recordings
    IReplay *replayControls = dynamic_cast<IReplay *> (cameraDevice.get());

    if (replayControls == nullptr)
    {
        cerr << "Unable to cast to IReplay interface" << endl;
        return 1;
    }

    // IMPORTANT: call the initialize method before working with the camera device
    if (cameraDevice->initialize() != CameraStatus::SUCCESS)
    {
        cerr << "Cannot initialize the camera device" << endl;
        return 1;
    }

    // turn off the looping of the playback
    replayControls->loop (false);

    // turn off the timestamps (this will speed up the conversion)
    replayControls->useTimestamps (false);

    // retrieve the total number of frames from the recording
    listener.numFrames = replayControls->frameCount();

    // register a data listener
    if (cameraDevice->registerDataListener (&listener) != CameraStatus::SUCCESS)
    {
        cerr << "Error registering data listener" << endl;
        return 1;
    }

    // register a playback stop listener. This will be called as soon
    // as the file has been played back once (because loop is turned off)
    replayControls->registerStopListener (&stopListener);

    // start capture mode
    if (cameraDevice->startCapture() != CameraStatus::SUCCESS)
    {
        cerr << "Error starting the capturing" << endl;
        return 1;
    }

    // block until the playback has finished
    stopListener.waitForStop();

    // stop capture mode
    if (cameraDevice->stopCapture() != CameraStatus::SUCCESS)
    {
        cerr << "Error stopping the capturing" << endl;
        return 1;
    }

    return 0;
}
